local collision = require "modules.collision"

go.property("velocity", vmath.vector3())

local gravity = 1800
local anim_playback_rate = 1.25

function init(self)

    self.position = go.get_position()
    self.sprite_flipped = false
    self.current_anim = "stand-idle"

    self.original_x = self.position.x

    self.ground_contact = false

    self.projectiles = {}

    self.aabb_id = collision.add_enemy(msg.url('.'))

    self.stunned = false
end


local function set_facing_direction(self)
    local enemy_position = self.position
    local player_position = self.player_position

    local x_diff = player_position.x - enemy_position.x

    if x_diff < 0 then
        self.sprite_flipped = true
    elseif x_diff > 0 then
        self.sprite_flipped = false
    end

    sprite.set_hflip("#base", self.sprite_flipped)
    sprite.set_hflip("#body", self.sprite_flipped)
    sprite.set_hflip("#head", self.sprite_flipped)
    sprite.set_hflip("#accessory", self.sprite_flipped)
end


local function apply_gravity(self, dt)
    -- if not self.ground_contact then
        -- Apply gravity, pulling the enemy down after the jump
        self.velocity.y = self.velocity.y - (gravity * dt)
    -- end
end


local function fire(self, enemy_position)
    local direction = self.sprite_flipped and -1 or 1
    local offset_x = 10 * direction
    local offset_y = self.is_crouching and -8 or 5
    local spawn_position = vmath.vector3(
        enemy_position.x + offset_x,
        enemy_position.y + offset_y,
        enemy_position.z
    )
    local speed = 500
    local projectile_velocity = vmath.vector3(speed * direction, 0, 0)
    local rotation = self.sprite_flipped and vmath.quat_rotation_z(math.pi) or nil
    local projectile = factory.create("#projectile_factory", spawn_position, rotation, { velocity = projectile_velocity })
    table.insert(self.projectiles, projectile)

end


local function crouch(self)
    local enemy_position = self.position
    local player_position = self.player_position

    if enemy_position.y > player_position.y then
        self.is_crouching = true
    else
        self.is_crouching = false
    end

    self.is_prone = false -- not implemented
end


local function jump(self, dt)
    local enemy_position = self.position
    local player_position = self.player_position

    local jump_condition = player_position.y > enemy_position.y

    -- Start the jump
    if jump_condition and self.can_jump and not self.stunned then
        local target_y = player_position.y
        local current_y = enemy_position.y
        local time_to_apex = 0.5 -- Time to reach the apex

        -- Calculate the initial velocity to reach the player's height
        self.velocity.y = (target_y - current_y) / time_to_apex + (0.5 * gravity * time_to_apex)
        self.ground_contact = false
        self.can_jump = false
        self.is_jumping = true
    end

    -- If jumping, update position and stop when reaching target height
    if self.is_jumping then
        local new_y = enemy_position.y + (self.velocity.y * dt)
        if new_y >= player_position.y then
            -- Transition from jumping to falling
            self.is_jumping = false
        end
        enemy_position.y = new_y
    end

    -- If not jumping and not on the ground, gravity governs
    if not self.is_jumping and not self.ground_contact then
        self.velocity.y = self.velocity.y - (gravity * dt)
        enemy_position.y = enemy_position.y + (self.velocity.y * dt)
    end

    -- Reset jump on ground contact
    if self.ground_contact then
        self.can_jump = true
        self.velocity.y = 0
    end

end


local attack_delay_time = 0.15


local function attack(self, dt)
    local enemy_position = self.position
    local player_position = self.player_position

    if math.abs(enemy_position.y - player_position.y) <= 20 then
        self.is_attacking = true
    else
        self.is_attacking = false
    end

    if self.is_attacking then
        if not self.is_charging_attack then
            self.is_charging_attack = true
            self.charge_timer = timer.delay(attack_delay_time, false, function()
                if self.is_charging_attack then
                    fire(self, enemy_position)
                    self.is_charging_attack = false
                    self.can_attack = false
                    timer.delay(0, false, function()
                        self.can_attack = true
                    end)
                end
            end)
        end
    else
        if self.is_charging_attack then
            self.is_charging_attack = false
            if self.charge_timer then
                timer.cancel(self.charge_timer)
                self.charge_timer = nil
            end
        end
    end
end


local function animate(self, dt)
    local new_anim

    local position
    if self.is_crouching and self.ground_contact then
        position = "crouch"
    else
        position = "stand"
    end

    if self.is_attacking and self.velocity.y ~= -0 then
        new_anim = "jump-attack"
    elseif self.is_attacking then
        new_anim = position .. "-attack"
    elseif self.velocity.y > 0 then
        new_anim = "jump-air"
    elseif self.velocity.y < 0 then
        new_anim = "jump-ground"
    else
        new_anim = position .. "-idle"
    end

    if self.stunned then
        if self.ground_contact then
            new_anim = "stand-damaged"
        else
            new_anim = "jump-damaged"
        end
    end

    if new_anim then
        if self.current_anim ~= new_anim then
            self.current_anim = new_anim
            sprite.play_flipbook("#base", new_anim, nil, { playback_rate = anim_playback_rate })
            sprite.play_flipbook("#body", new_anim, nil, { playback_rate = anim_playback_rate })
            sprite.play_flipbook("#head", new_anim, nil, { playback_rate = anim_playback_rate })
            sprite.play_flipbook("#accessory", new_anim, nil, { playback_rate = anim_playback_rate })
        end
    end
end


function update(self, dt)

    self.player_position = go.get_position("/player#player")

    collision.handle(self, self.position, false)

    apply_gravity(self, dt)

    jump(self, dt)

    if not self.stunned then
        crouch(self)
        attack(self, dt)
    end

    animate(self, dt)

    if not self.stunned then
        set_facing_direction(self)
    end
    
    self.position.x = self.original_x
    go.set_position(self.position + self.velocity * dt)

    self.wall_contact_left = false
    self.wall_contact_right = false
    self.ground_contact = false
end

function on_message(self, message_id, message, sender)

    if message_id == hash("damage") then
        self.stunned = true
        timer.delay(2, false, function()
            self.stunned = false
        end)
    end
end