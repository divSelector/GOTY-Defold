local collision = require "modules.collision"
local state = require "modules.state"

local tile_width = 16
local tile_height = 16

go.property("spawn_index", 0)
go.property("level_exit", false)

function init(self)
	self.aabb_id = collision.add_checkpoint(msg.url("."))
	self.id = go.get_id()

	self.position = go.get_position()
	self.fall = true
	self.collected = false

	if self.level_exit then
		sprite.play_flipbook(".", "bottle-magenta")
	end

	local pos = go.get_position()

    local _, _, w, h = tilemap.get_bounds("/level#tilemap")

    local tile_x = math.floor((pos.x - w * tile_width) / tile_width) + 2
    local tile_y = math.floor((pos.y - h * tile_height) / tile_height) + 2

    local is_x_odd = tile_x % 2 ~= 0
    local is_y_odd = tile_y % 2 ~= 0

    local duration_scale
    if (is_x_odd and not is_y_odd) or (not is_x_odd and is_y_odd) then
        duration_scale = 1
    else
        duration_scale = 2
    end

	go.animate(".", "scale", go.PLAYBACK_LOOP_PINGPONG, 0.9, go.EASING_OUTBOUNCE, duration_scale, 1)

    -- local delay_jump = math.random() * 2
    -- timer.delay(delay_jump, false, function()
    --     go.animate(".", "position.y", go.PLAYBACK_LOOP_PINGPONG, pos.y - 10, go.EASING_OUTBOUNCE, 2)
    -- end)
end

function update(self, dt)

    self.player_position = go.get_position("/player#player")

    local distance_from_player = vmath.length(self.player_position - self.position)

    if distance_from_player > 500 then
        return
    end

	local touching_ground = collision.check_checkpoint(self)

	if self.fall then
		local pos = self.position

		pos.y = pos.y - 10
	
		go.set_position(pos)
	
		self.position = pos
	end

	if touching_ground and not self.fall then
		local pos = self.position

		pos.y = pos.y + 20
	
		go.set_position(pos)
	
		self.position = pos
	end

end

function on_message(self, message_id, message, sender)
	
	if message_id == hash("collect") then

		if self.collected then
			return
		end

		self.collected = true
		
		if self.level_exit then
			collision.destroy(self.aabb_id)
			state.pause_allowed = false
			state.current_level_index = state.current_level_index + 1
			state.current_level = state.levels[state.current_level_index]
			msg.post("main:/main#manager", "load_level")
		else
			msg.post("/level#level", "set_spawn_point", {
				spawn_point = self.spawn_index
			})
		end


	elseif message_id == hash("stop_fall") then
		self.fall = false
		
	end
end