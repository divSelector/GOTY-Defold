local collision = require "modules.collision"
local state = require "modules.state"

local tile_size = 16

local function render_tilemap(self)
    for _, layer in ipairs(self.data.layers) do
        if layer.type == "tilelayer" then
            for i, tile_id in ipairs(layer.data) do
                if tile_id > 0 then
                    local x = (i - 1) % layer.width + 1
                    local y = layer.height - math.floor((i - 1) / layer.width)
                    tilemap.set_tile("/level#tilemap", layer.name, x, y, tile_id)
                end
            end
        end
    end
end

local function set_player_spawn_position(self)
    local data = self.player_spawn_positions[self.spawn_point]
    local position = vmath.vector3()
    position.x = data.x
    position.y = data.y

    go.set_position(position, "/player#player")
end

local function get_spawn_positions(self, layer_name, snap_to_tile)
    local positions = {}

    local snap_to_tile = snap_to_tile or false

    for _, layer in ipairs(self.data.layers) do
        if layer.name == layer_name then
            for _, object in ipairs(layer.objects) do
                local x = object.x
                local y = (self.map.h * tile_size) - object.y
                
                if snap_to_tile then
                    x = math.floor(x / tile_size) * tile_size + tile_size / 2
                    y = math.floor(y / tile_size) * tile_size + tile_size / 2
                end

                table.insert(positions, {
                    id = object.id,
                    x = x,
                    y = y
                })
            end
            break
        end
    end

    table.sort(positions, function(a, b)
        return a.id < b.id
    end)

    return positions
end


local function spawn_enemies(self)
    for _, spawn_position in ipairs(self.enemy_spawn_positions) do
        local enemy = factory.create("#enemy_factory", vmath.vector3(spawn_position.x, spawn_position.y, 0))
        table.insert(self.enemies, enemy)
    end
end


local function spawn_checkpoints(self)
    for spawn_index, spawn_position in ipairs(self.player_spawn_positions) do
        
        local is_last_checkpoint = spawn_index == #self.player_spawn_positions

        local checkpoint = factory.create("#checkpoint_factory", vmath.vector3(spawn_position.x, spawn_position.y, 0), nil, {
            spawn_index = spawn_index,
            level_exit = is_last_checkpoint
        })
        
        table.insert(self.checkpoints, checkpoint)
    end
end


local function group_platforms_by_adjacency(spawn_positions)
    local groups = {}
    local visited = {}


    local function is_adjacent(pos1, pos2)
        return math.abs(pos1.x - pos2.x) <= tile_size and pos1.y == pos2.y
    end

    local function gather_group(index, group)
        if visited[index] then return end
        visited[index] = true
        table.insert(group, spawn_positions[index])

        for i, pos in ipairs(spawn_positions) do
            if not visited[i] and is_adjacent(spawn_positions[index], pos) then
                gather_group(i, group)
            end
        end
    end

    for i = 1, #spawn_positions do
        if not visited[i] then
            local group = {}
            gather_group(i, group)
            table.insert(groups, group)
        end
    end

    return groups
end



local function spawn_platforms(self)
    local grouped_platform_positions = group_platforms_by_adjacency(self.platform_spawn_positions)

    for group_index, group in ipairs(grouped_platform_positions) do
        table.insert(self.platform_groups, {})
        for _, spawn_position in ipairs(group) do
            local platform = factory.create("#platform_factory", vmath.vector3(spawn_position.x, spawn_position.y, 0), nil, {
                tile_index = 3,
                velocity = vmath.vector3(100, 0, 0),
                group_index = group_index
            })
            
            table.insert(self.platform_groups[group_index], platform)

            table.insert(self.platforms, platform)
        end
    end
end



local function spawn_balls(self)
    for index, spawn_position in ipairs(self.ball_spawn_positions) do
        local ball = factory.create("#ball_factory", vmath.vector3(spawn_position.x, spawn_position.y, 0), nil, {
            star = index
        })
        table.insert(self.balls, ball)
    end
end


function init(self)

    collision.init()

    self.spawn_point = 1

    local x, y, w, h = tilemap.get_bounds("#tilemap")
    self.map = {x=x, y=y, w=w, h=h}

    local resource = sys.load_resource("/resource/tilemaps/" .. state.current_level .. ".tmj")
    if resource then
        self.data = json.decode(resource)

        render_tilemap(self)

        self.player_spawn_positions = get_spawn_positions(self, "player_spawn")
        self.checkpoints = {}
        spawn_checkpoints(self)
        set_player_spawn_position(self)

        self.enemy_spawn_positions = get_spawn_positions(self, "enemy_spawn")
        self.enemies = {}
        
        spawn_enemies(self)

        self.platform_spawn_positions = get_spawn_positions(self, "moving_platform", true)
        self.platforms = {}
        self.platform_groups = {}
        spawn_platforms(self)

        for _, platform in ipairs(self.platforms) do
            local platform_url = msg.url(platform)
            
            ---@diagnostic disable-next-line: assign-type-mismatch
            platform_url.fragment = "platform"
    
            local platform_group_index = go.get(platform_url, "group_index")
    
            msg.post(platform_url, "level_data", {
                platforms = self.platform_groups[platform_group_index]
            })
        end

        self.ball_spawn_positions = get_spawn_positions(self, "ball_spawn", true)
        self.balls = {}
        spawn_balls(self)

    end

    collision.add_tilemap("#tilemap", "ground")
    collision.add_tilemap("#tilemap", "top")

    local player_position = go.get_position("/player#player")
    collision.debug_draw_level(self.enemies, self.platforms)
    collision.debug_draw_player(player_position)
end

function update(self, dt)
    local player_position = go.get_position("/player#player")

    if player_position.y < 0 then
        set_player_spawn_position(self)
    end

end

function on_message(self, message_id, message, sender)
    if message_id == hash("set_spawn_point") then
        self.spawn_point = message.spawn_point
    end
end