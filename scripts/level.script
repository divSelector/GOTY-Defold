local collision = require "modules.collision"

local tile_size = 16

local function set_player_spawn_position(self)
    local data = self.player_spawn_positions[self.spawn_point]
    local position = vmath.vector3()
    position.x = data.x
    position.y = data.y

    go.set_position(position, "/player#player")
end

local function get_spawn_positions(self, layer_name, snap_to_tile)
    local positions = {}

    local snap_to_tile = snap_to_tile or false

    for _, layer in ipairs(self.data.layers) do
        if layer.name == layer_name then
            for _, object in ipairs(layer.objects) do
                local x = object.x
                local y = (self.map.h * tile_size) - object.y
                
                if snap_to_tile then
                    x = math.floor(x / tile_size) * tile_size + tile_size / 2
                    y = math.floor(y / tile_size) * tile_size + tile_size / 2
                end

                table.insert(positions, {
                    id = object.id,
                    x = x,
                    y = y
                })
            end
            break
        end
    end

    table.sort(positions, function(a, b)
        return a.id < b.id
    end)

    return positions
end


local function spawn_enemies(self)
    for _, spawn_position in ipairs(self.enemy_spawn_positions) do
        local enemy = factory.create("#enemy_factory", vmath.vector3(spawn_position.x, spawn_position.y, 0))
        table.insert(self.enemies, enemy)
    end
end

local function spawn_platforms(self)
    for _, spawn_position in ipairs(self.platform_spawn_positions) do
        local platform = factory.create("#platform_factory", vmath.vector3(spawn_position.x, spawn_position.y, 0), nil, {
            index = 3,
            velocity = vmath.vector3(100,0,0)
        })
        table.insert(self.platforms, platform)
    end
end


function init(self)
    self.spawn_point = 1

    local x, y, w, h = tilemap.get_bounds("#tilemap")
    self.map = {x=x, y=y, w=w, h=h}
    
    local resource = sys.load_resource("/resource/tilemaps/one.tmj")
    if resource then
        self.data = json.decode(resource)

        self.player_spawn_positions = get_spawn_positions(self, "player_spawn")
        set_player_spawn_position(self)

        self.enemy_spawn_positions = get_spawn_positions(self, "enemy_spawn")
        self.enemies = {}
        spawn_enemies(self)

        self.platform_spawn_positions = get_spawn_positions(self, "moving_platform", true)
        self.platforms = {}
        spawn_platforms(self)

    end

    collision.add_tilemap("#tilemap", "ground")
    collision.add_tilemap("#tilemap", "top")
end

function update(self, dt)
    local player_position = go.get_position("/player#player")

    msg.post("/player#player", "level_data", {
        enemies = self.enemies,
        platforms = self.platforms
    })

    for _, platform in ipairs(self.platforms) do
        local platform_pos = go.get_position(platform)
        local platform_url = msg.url(platform)
        
        ---@diagnostic disable-next-line: assign-type-mismatch
        platform_url.fragment = "platform"
        
        local platform_vel = go.get(platform_url, "velocity")
        platform_pos = platform_pos + platform_vel * dt
        go.set_position(platform_pos, platform)
        msg.post(platform_url, "level_data", {
            platforms = self.platforms
        })
    end

    if player_position.y < 0 then
        set_player_spawn_position(self)
    end
end